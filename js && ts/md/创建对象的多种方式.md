### 1. 工厂模式

```javascript
interface Person extends Object {
  name: string;
  getName: () => void;
}
function createPerson(name: string): Person {
  var o: Person = {} as Person;
  o.name = name;
  o.getName = () => {
    console.log(this.name);
  }
  return o;
}
```

缺点: 对象无法识别，因为所有的实例都指向一个对象

### 2. 构造函数模式

```javascript
function Person(name) {
  this.name = name;
  this.getName = function() {
    console.log(this.name);
  }
}

var person1 = new Person(`kevin`);
```

优点：实例可以识别为一个特定的类型

缺点：每次创建实例时，每个方法都要被创建一次

### 2.1 构造函数模式优化

```javascript
function Person(name) {
  this.name = name;
  this.getName = getName;
}

function getName = function() {
    console.log(this.name);
}

var person1 = new Person(`kevin`);
```

优点： 解决了每次创建实例都要重新创建方法的问题

确定：这封装，emmmmm....

### 3. 原型模式

```javascript
function Person() {
}

Person.prototype.name = 'kevin';
Person.prototype.getName = function() {
  console.log(this.name);
}

var person1 = new Person();
```

优点：方法不会重新创建

缺点：所有的属性和方法共享，不能初始化参数

### 3.1 原型模式优化

```javascript
function Person() {
}

Person.prototype = {
    name: 'kevin',
    getName: function() {
		console.log(this.name);
    }
}

var person1 = new Person();
```

优点：封装性好了一点

缺点：重写原型导致原型本身的属性丢失，如constructor属性

### 3.2 原型模式优化

```javascript
function Person() {
}

Person.prototype = {
    constructor: Person,
    name: 'kevin',
    getName: function() {
		console.log(this.name);
    }
}

var person1 = new Person();
```

优点：实例可以通过constructor属性找到所属构造函数

缺点：原型模式该有的缺点还是有

### 4. 组合模式

构造函数和原型模式双剑合璧。

```javascript
function Person(name) {
  this.name = name;
}
Person.prototype.getName = function() {
  console.log(this.name);
}

var person1 = new Person('kevin');
```

优点：该共享的共享，该私有的私有，使用最广泛的方式

缺点：有的人就是希望全部写在一起，即更好的封装性

### 4.1 动态原型模式

